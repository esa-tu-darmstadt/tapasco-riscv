//
// Generated by Bluespec Compiler (build e76ca21)
//
// On Thu Aug 27 12:33:48 CEST 2020
//
//
// Ports:
// Name                         I/O  size props
// rv_rstn                        O     1
// rv_reset                       O     1
// tapasco_intr                   O     1
// reqEN                          O     1
// resEN                          O     1 const
// saxi_arready                   O     1 reg
// saxi_rvalid                    O     1 reg
// saxi_rdata                     O    32
// saxi_rresp                     O     2
// saxi_awready                   O     1
// saxi_wready                    O     1
// saxi_bvalid                    O     1 reg
// saxi_bresp                     O     2
// CLK                            I     1 clock
// RST_N                          I     1 reset
// reqRDY_req_rdy                 I     1
// resRDY_res_rdy                 I     1 unused
// saxi_arvalid                   I     1
// saxi_araddr                    I    32 reg
// saxi_arprot                    I     3 reg
// saxi_rready                    I     1
// saxi_awvalid                   I     1
// saxi_awaddr                    I    32
// saxi_awprot                    I     3
// saxi_wvalid                    I     1
// saxi_wdata                     I    32
// saxi_wstrb                     I     4
// saxi_bready                    I     1
//
// Combinational paths from inputs to outputs:
//   reqRDY_req_rdy -> reqEN
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkRVController(CLK,
		      RST_N,

		      rv_rstn,

		      rv_reset,

		      tapasco_intr,

		      reqRDY_req_rdy,

		      resRDY_res_rdy,

		      reqEN,

		      resEN,

		      saxi_arready,

		      saxi_arvalid,

		      saxi_araddr,

		      saxi_arprot,

		      saxi_rvalid,

		      saxi_rready,

		      saxi_rdata,

		      saxi_rresp,

		      saxi_awready,

		      saxi_awvalid,

		      saxi_awaddr,

		      saxi_awprot,

		      saxi_wready,

		      saxi_wvalid,

		      saxi_wdata,

		      saxi_wstrb,

		      saxi_bvalid,

		      saxi_bready,

		      saxi_bresp);
  input  CLK;
  input  RST_N;

  // value method rv_rstn
  output rv_rstn;

  // value method rv_reset
  output rv_reset;

  // value method tapasco_intr
  output tapasco_intr;

  // action method reqRDY
  input  reqRDY_req_rdy;

  // action method resRDY
  input  resRDY_res_rdy;

  // value method reqEN
  output reqEN;

  // value method resEN
  output resEN;

  // value method saxi_rd_arready
  output saxi_arready;

  // action method saxi_rd_parvalid
  input  saxi_arvalid;

  // action method saxi_rd_paraddr
  input  [31 : 0] saxi_araddr;

  // action method saxi_rd_parprot
  input  [2 : 0] saxi_arprot;

  // value method saxi_rd_rvalid
  output saxi_rvalid;

  // action method saxi_rd_prready
  input  saxi_rready;

  // value method saxi_rd_rdata
  output [31 : 0] saxi_rdata;

  // value method saxi_rd_rresp
  output [1 : 0] saxi_rresp;

  // value method saxi_wr_awready
  output saxi_awready;

  // action method saxi_wr_pawvalid
  input  saxi_awvalid;

  // action method saxi_wr_pawaddr
  input  [31 : 0] saxi_awaddr;

  // action method saxi_wr_pawprot
  input  [2 : 0] saxi_awprot;

  // value method saxi_wr_wready
  output saxi_wready;

  // action method saxi_wr_pwvalid
  input  saxi_wvalid;

  // action method saxi_wr_pwdata
  input  [31 : 0] saxi_wdata;

  // action method saxi_wr_pwstrb
  input  [3 : 0] saxi_wstrb;

  // value method saxi_wr_bvalid
  output saxi_bvalid;

  // action method saxi_wr_pbready
  input  saxi_bready;

  // value method saxi_wr_bresp
  output [1 : 0] saxi_bresp;

  // signals for module outputs
  wire [31 : 0] saxi_rdata;
  wire [1 : 0] saxi_bresp, saxi_rresp;
  wire reqEN,
       resEN,
       rv_reset,
       rv_rstn,
       saxi_arready,
       saxi_awready,
       saxi_bvalid,
       saxi_rvalid,
       saxi_wready,
       tapasco_intr;

  // inlined wires
  wire [36 : 0] wr_s_dataIn_rv$port0__write_1,
		wr_s_dataIn_rv$port1__read,
		wr_s_dataIn_rv$port2__read;
  wire [35 : 0] wr_s_addrIn_rv$port0__write_1,
		wr_s_addrIn_rv$port1__read,
		wr_s_addrIn_rv$port2__read;
  wire intrWire$whas,
       startWire$whas,
       stdinBaseWire$whas,
       stdinSizeWire$whas,
       stdoutBaseWire$whas,
       stdoutSizeWire$whas,
       wr_s_addrIn_rv$EN_port0__write,
       wr_s_addrIn_rv$EN_port1__write,
       wr_s_dataIn_rv$EN_port0__write,
       wr_s_dataIn_rv$EN_port1__write;

  // register arg0
  reg [31 : 0] arg0;
  wire [31 : 0] arg0$D_IN;
  wire arg0$EN;

  // register arg1
  reg [31 : 0] arg1;
  wire [31 : 0] arg1$D_IN;
  wire arg1$EN;

  // register arg2
  reg [31 : 0] arg2;
  wire [31 : 0] arg2$D_IN;
  wire arg2$EN;

  // register arg3
  reg [31 : 0] arg3;
  wire [31 : 0] arg3$D_IN;
  wire arg3$EN;

  // register arg4
  reg [31 : 0] arg4;
  wire [31 : 0] arg4$D_IN;
  wire arg4$EN;

  // register counter
  reg [63 : 0] counter;
  wire [63 : 0] counter$D_IN;
  wire counter$EN;

  // register grace
  reg [6 : 0] grace;
  wire [6 : 0] grace$D_IN;
  wire grace$EN;

  // register resetBSV
  reg resetBSV;
  wire resetBSV$D_IN, resetBSV$EN;

  // register ret
  reg [63 : 0] ret;
  wire [63 : 0] ret$D_IN;
  wire ret$EN;

  // register state
  reg [1 : 0] state;
  reg [1 : 0] state$D_IN;
  wire state$EN;

  // register stdin_base
  reg [31 : 0] stdin_base;
  wire [31 : 0] stdin_base$D_IN;
  wire stdin_base$EN;

  // register stdin_size
  reg [31 : 0] stdin_size;
  wire [31 : 0] stdin_size$D_IN;
  wire stdin_size$EN;

  // register stdout_base
  reg [31 : 0] stdout_base;
  wire [31 : 0] stdout_base$D_IN;
  wire stdout_base$EN;

  // register stdout_size
  reg [31 : 0] stdout_size;
  wire [31 : 0] stdout_size$D_IN;
  wire stdout_size$EN;

  // register wr_s_addrIn_rv
  reg [35 : 0] wr_s_addrIn_rv;
  wire [35 : 0] wr_s_addrIn_rv$D_IN;
  wire wr_s_addrIn_rv$EN;

  // register wr_s_dataIn_rv
  reg [36 : 0] wr_s_dataIn_rv;
  wire [36 : 0] wr_s_dataIn_rv$D_IN;
  wire wr_s_dataIn_rv$EN;

  // ports of submodule rd_s_in
  wire [34 : 0] rd_s_in$D_IN, rd_s_in$D_OUT;
  wire rd_s_in$CLR, rd_s_in$DEQ, rd_s_in$EMPTY_N, rd_s_in$ENQ, rd_s_in$FULL_N;

  // ports of submodule rd_s_out
  reg [33 : 0] rd_s_out$D_IN;
  wire [33 : 0] rd_s_out$D_OUT;
  wire rd_s_out$CLR,
       rd_s_out$DEQ,
       rd_s_out$EMPTY_N,
       rd_s_out$ENQ,
       rd_s_out$FULL_N;

  // ports of submodule wr_s_in
  wire [70 : 0] wr_s_in$D_IN, wr_s_in$D_OUT;
  wire wr_s_in$CLR, wr_s_in$DEQ, wr_s_in$EMPTY_N, wr_s_in$ENQ, wr_s_in$FULL_N;

  // ports of submodule wr_s_out
  wire [1 : 0] wr_s_out$D_IN, wr_s_out$D_OUT;
  wire wr_s_out$CLR,
       wr_s_out$DEQ,
       wr_s_out$EMPTY_N,
       wr_s_out$ENQ,
       wr_s_out$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_bsvreset,
       WILL_FIRE_RL_handle_start,
       WILL_FIRE_RL_handle_write,
       WILL_FIRE_RL_startGracePeriod,
       WILL_FIRE_RL_writeStdinBase,
       WILL_FIRE_RL_writeStdinSize,
       WILL_FIRE_RL_writeStdoutBase,
       WILL_FIRE_RL_writeStdoutSize;

  // inputs to muxes for submodule ports
  wire [63 : 0] MUX_counter$write_1__VAL_1;
  wire [6 : 0] MUX_grace$write_1__VAL_1;
  wire MUX_state$write_1__SEL_1;

  // remaining internal signals
  wire [63 : 0] x__h4140, x__h4226;
  wire [31 : 0] x_data__h3631;

  // value method rv_rstn
  assign rv_rstn = state != 2'd0 ;

  // value method rv_reset
  assign rv_reset = state == 2'd0 ;

  // value method tapasco_intr
  assign tapasco_intr = state == 2'd3 ;

  // value method reqEN
  assign reqEN = WILL_FIRE_RL_bsvreset ;

  // value method resEN
  assign resEN = 1'b0 ;

  // value method saxi_rd_arready
  assign saxi_arready = rd_s_in$FULL_N ;

  // value method saxi_rd_rvalid
  assign saxi_rvalid = rd_s_out$EMPTY_N ;

  // value method saxi_rd_rdata
  assign saxi_rdata = rd_s_out$EMPTY_N ? rd_s_out$D_OUT[33:2] : 32'd0 ;

  // value method saxi_rd_rresp
  assign saxi_rresp = rd_s_out$EMPTY_N ? rd_s_out$D_OUT[1:0] : 2'd0 ;

  // value method saxi_wr_awready
  assign saxi_awready = !wr_s_addrIn_rv[35] ;

  // value method saxi_wr_wready
  assign saxi_wready = !wr_s_dataIn_rv[36] ;

  // value method saxi_wr_bvalid
  assign saxi_bvalid = wr_s_out$EMPTY_N ;

  // value method saxi_wr_bresp
  assign saxi_bresp = wr_s_out$EMPTY_N ? wr_s_out$D_OUT : 2'd0 ;

  // submodule rd_s_in
  SizedFIFO #(.p1width(32'd35),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) rd_s_in(.RST(RST_N),
				       .CLK(CLK),
				       .D_IN(rd_s_in$D_IN),
				       .ENQ(rd_s_in$ENQ),
				       .DEQ(rd_s_in$DEQ),
				       .CLR(rd_s_in$CLR),
				       .D_OUT(rd_s_in$D_OUT),
				       .FULL_N(rd_s_in$FULL_N),
				       .EMPTY_N(rd_s_in$EMPTY_N));

  // submodule rd_s_out
  SizedFIFO #(.p1width(32'd34),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) rd_s_out(.RST(RST_N),
					.CLK(CLK),
					.D_IN(rd_s_out$D_IN),
					.ENQ(rd_s_out$ENQ),
					.DEQ(rd_s_out$DEQ),
					.CLR(rd_s_out$CLR),
					.D_OUT(rd_s_out$D_OUT),
					.FULL_N(rd_s_out$FULL_N),
					.EMPTY_N(rd_s_out$EMPTY_N));

  // submodule wr_s_in
  SizedFIFO #(.p1width(32'd71),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) wr_s_in(.RST(RST_N),
				       .CLK(CLK),
				       .D_IN(wr_s_in$D_IN),
				       .ENQ(wr_s_in$ENQ),
				       .DEQ(wr_s_in$DEQ),
				       .CLR(wr_s_in$CLR),
				       .D_OUT(wr_s_in$D_OUT),
				       .FULL_N(wr_s_in$FULL_N),
				       .EMPTY_N(wr_s_in$EMPTY_N));

  // submodule wr_s_out
  SizedFIFO #(.p1width(32'd2),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) wr_s_out(.RST(RST_N),
					.CLK(CLK),
					.D_IN(wr_s_out$D_IN),
					.ENQ(wr_s_out$ENQ),
					.DEQ(wr_s_out$DEQ),
					.CLR(wr_s_out$CLR),
					.D_OUT(wr_s_out$D_OUT),
					.FULL_N(wr_s_out$FULL_N),
					.EMPTY_N(wr_s_out$EMPTY_N));

  // rule RL_bsvreset
  assign WILL_FIRE_RL_bsvreset = state == 2'd1 && resetBSV && reqRDY_req_rdy ;

  // rule RL_handle_write
  assign WILL_FIRE_RL_handle_write = wr_s_in$EMPTY_N && wr_s_out$FULL_N ;

  // rule RL_writeStdoutBase
  assign WILL_FIRE_RL_writeStdoutBase = state == 2'd0 && stdoutBaseWire$whas ;

  // rule RL_writeStdoutSize
  assign WILL_FIRE_RL_writeStdoutSize = state == 2'd0 && stdoutSizeWire$whas ;

  // rule RL_writeStdinBase
  assign WILL_FIRE_RL_writeStdinBase = state == 2'd0 && stdinBaseWire$whas ;

  // rule RL_writeStdinSize
  assign WILL_FIRE_RL_writeStdinSize = state == 2'd0 && stdinSizeWire$whas ;

  // rule RL_handle_start
  assign WILL_FIRE_RL_handle_start = state == 2'd0 && startWire$whas ;

  // rule RL_startGracePeriod
  assign WILL_FIRE_RL_startGracePeriod = state == 2'd1 && intrWire$whas ;

  // inputs to muxes for submodule ports
  assign MUX_state$write_1__SEL_1 = state == 2'd2 && grace == 7'd0 ;
  assign MUX_counter$write_1__VAL_1 = counter + 64'd1 ;
  assign MUX_grace$write_1__VAL_1 = grace - 7'd1 ;

  // inlined wires
  assign stdoutBaseWire$whas =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0080 ;
  assign stdoutSizeWire$whas =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0090 ;
  assign stdinBaseWire$whas =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h00A0 ;
  assign stdinSizeWire$whas =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h00B0 ;
  assign startWire$whas =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0 &&
	     wr_s_in$D_OUT[38:7] != 32'd0 ;
  assign intrWire$whas =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h4000 &&
	     wr_s_in$D_OUT[38:7] != 32'd0 ;
  assign wr_s_addrIn_rv$EN_port0__write =
	     !wr_s_addrIn_rv[35] && saxi_awvalid ;
  assign wr_s_addrIn_rv$port0__write_1 = { 1'd1, saxi_awaddr, saxi_awprot } ;
  assign wr_s_addrIn_rv$port1__read =
	     wr_s_addrIn_rv$EN_port0__write ?
	       wr_s_addrIn_rv$port0__write_1 :
	       wr_s_addrIn_rv ;
  assign wr_s_addrIn_rv$EN_port1__write =
	     wr_s_addrIn_rv$port1__read[35] &&
	     wr_s_dataIn_rv$port1__read[36] &&
	     wr_s_in$FULL_N ;
  assign wr_s_addrIn_rv$port2__read =
	     wr_s_addrIn_rv$EN_port1__write ?
	       36'h2AAAAAAAA :
	       wr_s_addrIn_rv$port1__read ;
  assign wr_s_dataIn_rv$EN_port0__write = !wr_s_dataIn_rv[36] && saxi_wvalid ;
  assign wr_s_dataIn_rv$port0__write_1 = { 1'd1, saxi_wdata, saxi_wstrb } ;
  assign wr_s_dataIn_rv$port1__read =
	     wr_s_dataIn_rv$EN_port0__write ?
	       wr_s_dataIn_rv$port0__write_1 :
	       wr_s_dataIn_rv ;
  assign wr_s_dataIn_rv$EN_port1__write =
	     wr_s_addrIn_rv$port1__read[35] &&
	     wr_s_dataIn_rv$port1__read[36] &&
	     wr_s_in$FULL_N ;
  assign wr_s_dataIn_rv$port2__read =
	     wr_s_dataIn_rv$EN_port1__write ?
	       37'h0AAAAAAAAA :
	       wr_s_dataIn_rv$port1__read ;

  // register arg0
  assign arg0$D_IN = wr_s_in$D_OUT[38:7] ;
  assign arg0$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0020 ;

  // register arg1
  assign arg1$D_IN = wr_s_in$D_OUT[38:7] ;
  assign arg1$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0030 ;

  // register arg2
  assign arg2$D_IN = wr_s_in$D_OUT[38:7] ;
  assign arg2$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0040 ;

  // register arg3
  assign arg3$D_IN = wr_s_in$D_OUT[38:7] ;
  assign arg3$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0050 ;

  // register arg4
  assign arg4$D_IN = wr_s_in$D_OUT[38:7] ;
  assign arg4$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     wr_s_in$D_OUT[54:39] == 16'h0060 ;

  // register counter
  assign counter$D_IN = (state != 2'd0) ? MUX_counter$write_1__VAL_1 : 64'd0 ;
  assign counter$EN = state != 2'd0 || WILL_FIRE_RL_handle_start ;

  // register grace
  assign grace$D_IN = (state == 2'd2) ? MUX_grace$write_1__VAL_1 : 7'd120 ;
  assign grace$EN = state == 2'd2 || WILL_FIRE_RL_startGracePeriod ;

  // register resetBSV
  assign resetBSV$D_IN = !WILL_FIRE_RL_bsvreset ;
  assign resetBSV$EN = WILL_FIRE_RL_bsvreset || WILL_FIRE_RL_handle_start ;

  // register ret
  assign ret$D_IN = (wr_s_in$D_OUT[54:39] == 16'h0010) ? x__h4140 : x__h4226 ;
  assign ret$EN =
	     WILL_FIRE_RL_handle_write && wr_s_in$D_OUT[6:3] != 4'd0 &&
	     (wr_s_in$D_OUT[54:39] == 16'h0010 ||
	      wr_s_in$D_OUT[54:39] == 16'h0014) ;

  // register state
  always@(MUX_state$write_1__SEL_1 or
	  state or WILL_FIRE_RL_handle_start or WILL_FIRE_RL_startGracePeriod)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_state$write_1__SEL_1: state$D_IN = 2'd3;
      state == 2'd3: state$D_IN = 2'd0;
      WILL_FIRE_RL_handle_start: state$D_IN = 2'd1;
      WILL_FIRE_RL_startGracePeriod: state$D_IN = 2'd2;
      default: state$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign state$EN =
	     state == 2'd2 && grace == 7'd0 || state == 2'd3 ||
	     WILL_FIRE_RL_handle_start ||
	     WILL_FIRE_RL_startGracePeriod ;

  // register stdin_base
  assign stdin_base$D_IN =
	     WILL_FIRE_RL_writeStdinBase ? wr_s_in$D_OUT[38:7] : 32'd0 ;
  assign stdin_base$EN = WILL_FIRE_RL_writeStdinBase || state == 2'd3 ;

  // register stdin_size
  assign stdin_size$D_IN =
	     WILL_FIRE_RL_writeStdinSize ? wr_s_in$D_OUT[38:7] : 32'd0 ;
  assign stdin_size$EN = WILL_FIRE_RL_writeStdinSize || state == 2'd3 ;

  // register stdout_base
  assign stdout_base$D_IN =
	     WILL_FIRE_RL_writeStdoutBase ? wr_s_in$D_OUT[38:7] : 32'd0 ;
  assign stdout_base$EN = WILL_FIRE_RL_writeStdoutBase || state == 2'd3 ;

  // register stdout_size
  assign stdout_size$D_IN =
	     WILL_FIRE_RL_writeStdoutSize ? wr_s_in$D_OUT[38:7] : 32'd0 ;
  assign stdout_size$EN = WILL_FIRE_RL_writeStdoutSize || state == 2'd3 ;

  // register wr_s_addrIn_rv
  assign wr_s_addrIn_rv$D_IN = wr_s_addrIn_rv$port2__read ;
  assign wr_s_addrIn_rv$EN = 1'b1 ;

  // register wr_s_dataIn_rv
  assign wr_s_dataIn_rv$D_IN = wr_s_dataIn_rv$port2__read ;
  assign wr_s_dataIn_rv$EN = 1'b1 ;

  // submodule rd_s_in
  assign rd_s_in$D_IN = { saxi_araddr, saxi_arprot } ;
  assign rd_s_in$ENQ = rd_s_in$FULL_N && saxi_arvalid ;
  assign rd_s_in$DEQ = rd_s_in$EMPTY_N && rd_s_out$FULL_N ;
  assign rd_s_in$CLR = 1'b0 ;

  // submodule rd_s_out
  always@(rd_s_in$D_OUT or
	  x_data__h3631 or
	  ret or
	  arg0 or
	  arg1 or
	  arg2 or
	  arg3 or
	  arg4 or
	  counter or stdout_base or stdout_size or stdin_base or stdin_size)
  begin
    case (rd_s_in$D_OUT[10:3])
      8'h0: rd_s_out$D_IN = { x_data__h3631, 2'd0 };
      8'h10: rd_s_out$D_IN = { ret[31:0], 2'd0 };
      8'h14: rd_s_out$D_IN = { ret[63:32], 2'd0 };
      8'h20: rd_s_out$D_IN = { arg0, 2'd0 };
      8'h30: rd_s_out$D_IN = { arg1, 2'd0 };
      8'h40: rd_s_out$D_IN = { arg2, 2'd0 };
      8'h50: rd_s_out$D_IN = { arg3, 2'd0 };
      8'h60: rd_s_out$D_IN = { arg4, 2'd0 };
      8'h70: rd_s_out$D_IN = { counter[31:0], 2'd0 };
      8'h74: rd_s_out$D_IN = { counter[63:32], 2'd0 };
      8'h80: rd_s_out$D_IN = { stdout_base, 2'd0 };
      8'h90: rd_s_out$D_IN = { stdout_size, 2'd0 };
      8'hA0: rd_s_out$D_IN = { stdin_base, 2'd0 };
      8'hB0: rd_s_out$D_IN = { stdin_size, 2'd0 };
      default: rd_s_out$D_IN = 34'd0;
    endcase
  end
  assign rd_s_out$ENQ = rd_s_in$EMPTY_N && rd_s_out$FULL_N ;
  assign rd_s_out$DEQ = rd_s_out$EMPTY_N && saxi_rready ;
  assign rd_s_out$CLR = 1'b0 ;

  // submodule wr_s_in
  assign wr_s_in$D_IN =
	     { wr_s_addrIn_rv$port1__read[34:3],
	       wr_s_dataIn_rv$port1__read[35:0],
	       wr_s_addrIn_rv$port1__read[2:0] } ;
  assign wr_s_in$ENQ =
	     wr_s_addrIn_rv$port1__read[35] &&
	     wr_s_dataIn_rv$port1__read[36] &&
	     wr_s_in$FULL_N ;
  assign wr_s_in$DEQ = WILL_FIRE_RL_handle_write ;
  assign wr_s_in$CLR = 1'b0 ;

  // submodule wr_s_out
  assign wr_s_out$D_IN = 2'd0 ;
  assign wr_s_out$ENQ = WILL_FIRE_RL_handle_write ;
  assign wr_s_out$DEQ = wr_s_out$EMPTY_N && saxi_bready ;
  assign wr_s_out$CLR = 1'b0 ;

  // remaining internal signals
  assign x__h4140 = { ret[63:32], wr_s_in$D_OUT[38:7] } ;
  assign x__h4226 = { wr_s_in$D_OUT[38:7], ret[31:0] } ;
  assign x_data__h3631 = (state == 2'd0) ? 32'd0 : 32'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        arg0 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	arg1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	arg2 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	arg3 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	arg4 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	counter <= `BSV_ASSIGNMENT_DELAY 64'd0;
	grace <= `BSV_ASSIGNMENT_DELAY 7'd0;
	resetBSV <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ret <= `BSV_ASSIGNMENT_DELAY 64'd0;
	state <= `BSV_ASSIGNMENT_DELAY 2'd0;
	stdin_base <= `BSV_ASSIGNMENT_DELAY 32'd0;
	stdin_size <= `BSV_ASSIGNMENT_DELAY 32'd0;
	stdout_base <= `BSV_ASSIGNMENT_DELAY 32'd0;
	stdout_size <= `BSV_ASSIGNMENT_DELAY 32'd0;
	wr_s_addrIn_rv <= `BSV_ASSIGNMENT_DELAY 36'h2AAAAAAAA;
	wr_s_dataIn_rv <= `BSV_ASSIGNMENT_DELAY 37'h0AAAAAAAAA;
      end
    else
      begin
        if (arg0$EN) arg0 <= `BSV_ASSIGNMENT_DELAY arg0$D_IN;
	if (arg1$EN) arg1 <= `BSV_ASSIGNMENT_DELAY arg1$D_IN;
	if (arg2$EN) arg2 <= `BSV_ASSIGNMENT_DELAY arg2$D_IN;
	if (arg3$EN) arg3 <= `BSV_ASSIGNMENT_DELAY arg3$D_IN;
	if (arg4$EN) arg4 <= `BSV_ASSIGNMENT_DELAY arg4$D_IN;
	if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
	if (grace$EN) grace <= `BSV_ASSIGNMENT_DELAY grace$D_IN;
	if (resetBSV$EN) resetBSV <= `BSV_ASSIGNMENT_DELAY resetBSV$D_IN;
	if (ret$EN) ret <= `BSV_ASSIGNMENT_DELAY ret$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
	if (stdin_base$EN)
	  stdin_base <= `BSV_ASSIGNMENT_DELAY stdin_base$D_IN;
	if (stdin_size$EN)
	  stdin_size <= `BSV_ASSIGNMENT_DELAY stdin_size$D_IN;
	if (stdout_base$EN)
	  stdout_base <= `BSV_ASSIGNMENT_DELAY stdout_base$D_IN;
	if (stdout_size$EN)
	  stdout_size <= `BSV_ASSIGNMENT_DELAY stdout_size$D_IN;
	if (wr_s_addrIn_rv$EN)
	  wr_s_addrIn_rv <= `BSV_ASSIGNMENT_DELAY wr_s_addrIn_rv$D_IN;
	if (wr_s_dataIn_rv$EN)
	  wr_s_dataIn_rv <= `BSV_ASSIGNMENT_DELAY wr_s_dataIn_rv$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    arg0 = 32'hAAAAAAAA;
    arg1 = 32'hAAAAAAAA;
    arg2 = 32'hAAAAAAAA;
    arg3 = 32'hAAAAAAAA;
    arg4 = 32'hAAAAAAAA;
    counter = 64'hAAAAAAAAAAAAAAAA;
    grace = 7'h2A;
    resetBSV = 1'h0;
    ret = 64'hAAAAAAAAAAAAAAAA;
    state = 2'h2;
    stdin_base = 32'hAAAAAAAA;
    stdin_size = 32'hAAAAAAAA;
    stdout_base = 32'hAAAAAAAA;
    stdout_size = 32'hAAAAAAAA;
    wr_s_addrIn_rv = 36'hAAAAAAAAA;
    wr_s_dataIn_rv = 37'h0AAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (state == 2'd3)
	$display("Resetting everything and issuing interrupt");
  end
  // synopsys translate_on
endmodule  // mkRVController

